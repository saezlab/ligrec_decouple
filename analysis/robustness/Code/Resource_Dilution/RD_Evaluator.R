#------------------------------------------------------------------------------#
# 0. Define resource_Robustness() ----------------------------------------------

#' Analyses LIANA prediction robustness when diluting resources
#'
#' @description This is not really a function, it is a full fledged script that
#' needs to be iterated easily and conveniently. Please familiarize yourself 
#' with the code before using this script, it is well commented throughout.
#' 
#' In brief, this script runs six LIANA methods from LIANA++ (call_connectome,
#' squidpy, call_natmi, call_italk, call_sca and cellchat) on one 
#' benchmarking data set and stores their predictions for which are the top most
#' relevant CCIs occuring. The resource used is OmniPath.
#' 
#' Using this information, we use resource_Dilute() on OmniPath. This process 
#' removes a proportion of interactions from OmniPath, and replaces them with
#' spurious interactions derived from mixing and matching genes extracted from
#' the testdata. Interactions that were ranked as relevant CCIs are excluded
#' from dilution. It is not uncommon to generate a gradient of dilution, say 
#' 10 % to 80 % in 10 % intervals.
#' 
#' LIANA is rerun on the diluted resources. For each result the top ranked CCIs
#' are extracted and compared to the original predictions. The overlap, mismatch
#' and proportion of diluted interactions among original top_ranked ones are
#' recorded and stored. Finally, all the relevant data generated by this 
#' function is returned in a list.
#' 
#' @param testdata A preprocessed Seurat object of test data that LIANA++ can 
#' run on.
#' 
#' @param feature_type Should dilution occur with all the genes profiled in
#' testdata (choose "generic") or with the most variable features (choose 
#' "variable")? As a string.
#' 
#' @param baseline_liana What were the baseline results for liana without
#' dilution? As a named list in the res_liana_with_warnings output format.
#' 
#' @param modify_baseline TRUE or FALSE. Should the top-ranked interactions from
#' the baseline be modifiable by dilution. Usually this is not the case, and 
#' almost all documentation is written from the perspective that the baseline is
#' not modifiable.
#' 
#' @param preserve_topology When diluting, two methods are implemented.
#' random_Dilute makes only a small effort to preserve the topology of the rows
#' that are diluted from resource, preserve_Dilute makes a far greater effort.
#' Choose TRUE for preserve_Dilute and FALSE for random_Dilute.
#' 
#' @param dilution_props A sequence of numerics (0-1) that indicate which 
#' proportions to dilute the resource with. For example c(0.1, 0.2, 0.3) would
#' compare the top ranked CCI's using undiluted OmniPath compared to OmniPath 
#' with 10 % of its rows diluted, undiluted vs 20 % diluted, and undiluted vs
#' 30 % diluted.
#' 
#' @param bundled_outputs Which outputs of the calculation would you like to 
#' return? Outputs are returned bundled up in a list. By default, only the analysis
#' of top_ranks and runtime data is returned, but more infomation can be returned.
#' Construct an atomic vector using all or some of "liana_results_OP", 
#' "resources_OP", "top_ranks_OP", "top_ranks_analysis","runtime", and 
#' "testdata" to tell the script which outputs should go in the output bundle.
#' 
#' "liana_results_OP": All the predicted CCI's from LIANA++ for each method and
#' dilution stage.
#' 
#' "resources_OP": All the resources that were used are returned.
#' 
#' "top_ranks_OP": All the highest ranked CCI's from LIANA++ for each method 
#' and dilution stage.
#' 
#' "top_ranks_analysis": How the diluted top predictions related to the 
#' undiluted predictions in terms of overlap, mismatch, proportion of fake 
#' interactions in top_ranks, and proportion of mismatch caused by fake 
#' interactions. 
#' 
#' "runtime": What was the runtime of this function was like.
#' 
#' "testdata": What was the testdata that was used in this run. Since that's 
#' also a user supplied Seurat, there is almost never a reason to return this.
#' 
#' @param number_ranks A named list. Each item is named after a method and is 
#' equal to the number of top interactions considered relevant for that method. 
#' 
#' For example, item one on the list may be called call_connectome and be equal 
#' to 500. This would signal to the function that for call_connectome, the top 
#' 500 CCI's are considered relevant and that these 500 are the ones that are to
#' be compared between the dilutions. Usually you consider the same number of
#' top_ranks for each method relevant.
#' 
#' @param master_seed  At some stages when diluting  a resource, randomness
#' is at play. Setting a master seed will ensure that dilute_Resource(), the 
#' function that dilutes the resources, runs the same way every time. Each 
#' instance of randomness within the scope of dilute_Resource() will run 
#' reproducibly.
#' 
#' @param methods_vector Which methods should the function run? Choose from
#' "call_connectome", "squidpy", "call_natmi", "call_italk", "call_sca" and
#' "cellchat". Supply the argument in the form of e.g. 
#' c("call_conncectome, "call_italk").
#' 
#' @param cellchat_nperms Cellchat is one of the slower methods, for test runs
#' it may be useful to set this parameter to 10 to speed up the analysis.
#' 
#' @param liana_warnings Either TRUE, FALSE or "divert". Should the warnings 
#' from LIANA++, which are often repetitive and unhelpful, be either suppressed
#' or alternatively diverted to the log folder? When these types of warning are
#' left in, they can often displace valuable warnings. Be careful with this 
#' setting, as suppressing warnings is obviously risky.
#'  
#' @param tag An additional tag that specifies the NATMI save files to this
#' iterator run.
#'  
#' @param warning_logfile Only if liana_warnings == "divert". The filepath
#' warnings should be saved to.
#' 
#' @return Depending on outputs arg, a list with many possible contents is 
#' returned.

resource_Robustness <- function(testdata,
                                feature_type,
                                preserve_topology,
                                modify_baseline,
                                dilution_props,
                                number_ranks,
                                master_seed,
                                bundled_outputs,
                                baseline_liana,
                                
                                tag,
                                
                                methods_vector,
                                cellchat_nperms,
                                liana_warnings,
                                warning_logfile) {
  
runtime <- list()
runtime[[str_glue("Iteration Start - Seed ", master_seed)]] <- Sys.time()

# Sanitize master_seed input
master_seed <- floor(master_seed)

print_Title(str_glue("Iteration ", 
                     master_seed, 
                     "  --  At ", 
                     as.character(Sys.time())),
            super = TRUE)


#------------------------------------------------------------------------------#
# 0. Preparing Logs ------------------------------------------------------------
{
  print_Title(
    str_glue("0. Preparing Logs", "                      --  Iteration ",
             master_seed))

  if(liana_warnings == "divert") {
    
    cat(str_glue("|=======================================",
                 "=======================================|"),
        "\n\n",
        str_glue(as.character(Sys.time()), ": Iteration  --  ", master_seed), 
        "\n\n\n",
        file = warning_logfile, 
        append = TRUE)


  }
  
}



#------------------------------------------------------------------------------#
# 1. Preparing resource_Dilute() Inputs ----------------------------------------
{
  print_Title(
    str_glue("1. Preparing resource_Dilute() Inputs", "   --  Iteration ", 
             master_seed))

  # 1.1 Get highest ranked interactions for undiluted conditions 
  {
  # baseline _liana is a good name for an argument but here we refer to it
  # differently.
  liana_results_OP_0 <- baseline_liana
    
    
  # Apply get_top_n_ranks for each method's results on OP_0 (i.e. undiluted)
  top_ranks_OP_0 <- list()
  
  for (method in methods_vector){
    
    # Because cellchat produces so many interactions all tied for 0, we need
    # to cut with ties
    if(method %in% c("cellchat", "squidpy")) {
      
      top_ranks_OP_0[[method]] <- 
        get_top_n_ranks(data_set  = liana_results_OP_0[[method]],
                        top_n     = number_ranks[[method]],
                        method    = method,
                        with_ties = TRUE)
      
    } else {
      
      top_ranks_OP_0[[method]] <- 
        get_top_n_ranks(data_set  = liana_results_OP_0[[method]],
                        top_n     = number_ranks[[method]],
                        method    = method,
                        with_ties = FALSE)
      
    }

    
  }
    
  rm(method)
  
  } # end of subpoint
  
  # 1.2 Format OmniPath and filter non-hits
  {
    
  
  # Format OmniPath_0 to be easier to work with and to pair it down to the 
  # columns relevant for the methods. Also add the isRandom column and the 
  # LR_Pair column. IsRandom tracks  whether an interaction has been randomly 
  # generated, LR_Pair helps identify individual interactions
  OmniPath_0 <- select_resource(c('OmniPath'))[["OmniPath"]] %>%
    select(source_genesymbol,
           target_genesymbol,
           source, 
           target,
           is_directed,
           is_stimulation,
           consensus_stimulation,
           is_inhibition,
           consensus_inhibition,
           category_intercell_source,
           category_intercell_target,
           genesymbol_intercell_source,
           genesymbol_intercell_target,
           entity_type_intercell_target,
           sources,
           references,
           entity_type_intercell_source,
           entity_type_intercell_target) %>%
    mutate(isRandom = FALSE) %>%
    unite("LR_Pair", 
          c(source_genesymbol, target_genesymbol), 
          remove = FALSE, 
          sep = "_") %>%
    relocate("LR_Pair", .after = last_col())
  
  # Filter OmniPath to only include interactions between genes which are 
  # represented in the data. 
  # This has no impact on the results, since the removed interactions can't be
  # evaluated by the methods as the necessary genes are missing.
  # The advantage here is that dilution later replaces genes from the resource
  # with genes in the data set; if we consider genes in the resource that are 
  # also represented in the data 'hits', then we are diluting the resource by 
  # inserting hits.
  # Making sure OP only had hits to begin with ensures we dilute hits with 
  # other hits, a fairer comparison than the alternative, which would be 
  # diluting hits and non-hits from OP with hits from the data.
  gene_names <- rownames(testdata@assays$RNA@data)
  
  OmniPath_0 <- OmniPath_0 %>%
    filter(source_genesymbol %in% gene_names) %>%
    filter(target_genesymbol %in% gene_names)
  
  # removing superfluous values
  rm(gene_names)
  
  
    
  } # end of subpoint
  
  # 1.4 Listify Data sets in the face of dilution steps
  {
  
  
  # Since we are about to perform the same analysis in the steps above but 
  # multiplied by each dilution step, we will turn our data sets into named 
  # lists sorted by method and sub categorized by dilution. Since the resource
  # will be the same for each method, this list isn't subdivided by method.
  
  resources_OP <- list("OmniPath_0" = OmniPath_0)
  
  # Create a named methods list from methods_vector, when we map over the list 
  # the names will be passed to the map output
  methods_list        <- as.list(methods_vector)
  names(methods_list) <- methods_vector
  
  
  # Create a nested list, where each liana_result is listed by method and then
  # dilution it was achieved at.
  liana_results_OP <-
    map(methods_list, function(method) {
      list(OmniPath_0 = liana_results_OP_0[[method]])
    })
  
  # Create a nested list, where each top_ranks tibble is listed by method and
  # then dilution it was achieved at.
  top_ranks_OP <-
    map(methods_list, function(method) {
      list(OmniPath_0 = top_ranks_OP_0[[method]])
    })
  
  # remove old data frames and methods_list, which we won't need for a while
  rm(OmniPath_0, liana_results_OP_0, top_ranks_OP_0, methods_list)
  
  } # end of subpoint
  
}



#------------------------------------------------------------------------------#
# 2. Diluting Resources ------------------------------------------------------
{
  print_Title(
    str_glue("2. Diluting Resources", "                   --  Iteration ", 
             master_seed))
  
  # 2.1 Generate diluted Resources for all dilution proportions
  {
  
  # If the baseline CCC predictions should not be altered, we summarize them
  # for each method here.
  if(modify_baseline == FALSE) {
    
    # Generating a unified top_rank_vector. We call it a list because that's what
    # the dilute_Resource() parameter is called.
    
    # For each method in methods_vector we collect all the LR_Pairs from the top
    # ranks. Then we reduce it down to unique LR_Pairs among them.
    top_rank_list <- 
      map(methods_vector, function(method) {
        
        top_ranks_OP[[method]]$OmniPath_0$LR_Pair 
        
      })       %>%
      unlist() %>%
      unique()
    
    cat("\n",
        str_glue("Preserved ", length(top_rank_list), " interactions."),
        "\n\n")
    
  } else if(modify_baseline == TRUE) {
    
    # If the baseline should be modified, we pass np interactions to preserve
    # to the dilution function.
    top_rank_list <- c()
    
    cat("\n",
        str_glue("No interactions were preserved."),
        "\n\n")
    
  }

  
  
  # Initiating a list of all dilutions
  dilutions_OP <- list()
  
  # lapply dilute_Resource() over every dilution proportion
  # and remove any dilution proportion entries that were impossible
  dilutions_OP <- 
    lapply(dilution_props, dilute_Resource, 
           resource          = resources_OP$OmniPath_0, 
           top_rank_list     = top_rank_list, 
           preserve_topology = preserve_topology,
           data_set          = testdata,
           feature_type      = feature_type,
           verbose           = TRUE, 
           master_seed       = master_seed) %>% 
    discard(is_null)
  
  
  # Add new dilutions to resources_OP
  resources_OP <- append(resources_OP, dilutions_OP)
  
  
  # Remove uneccesary Variables
  rm(dilutions_OP, top_rank_list)
  
  
  
  } # end of subpoint
  
}    



#------------------------------------------------------------------------------#
# 3. Rerun Liana and contrast predictions --------------------------------------
{
  print_Title(
    str_glue("3. Rerun Liana and contrast predictions","  --  Iteration ", 
             master_seed))
  
  # 3.1 Reapply individual methods with diluted resources
  {
  runtime[["Resource Dilution"]] <- Sys.time()
  
  
  # Iterate res_liana_with_warnings over all the diluted resources
  # We assign every argument but external_resource, which is supplied by the
  # lapply.
  liana_dilutions_OP <- 
    lapply(resources_OP[-1],
           res_liana_with_warnings,
           
           testdata        = testdata, 
           methods_vector  = methods_vector, 
           resource        = c('custom'), 
           
           liana_warnings  = liana_warnings, 
           warning_logfile = warning_logfile, 
           
           tag = tag,
           
           expr_prop       = 0.1,
           cellchat.params = list(nboot = cellchat_nperms, 
                                  expr_prop = 0.1,
                                  thresh = 1))
  
  # Merge with undiluted results
  liana_results_OP <- 
    liana_results_OP %>%
    transpose() %>%
    append(., liana_dilutions_OP) %>%
    transpose() 
  
  # Update runtime
  runtime[["Diluted LIANA"]] <- Sys.time()
  
  # Remove uneccesary Variables
  rm(liana_dilutions_OP)
    
    
  } # end of subpoint
  
  # 3.2 Get top_n_ranks for each method and dilution
  {
    
  # Create a named methods list from methods_vector, when we map over the list 
  # the names will be passed to the map output.
  methods_list        <- as.list(methods_vector)
  names(methods_list) <- methods_vector
  # Filter out permutation based methods, they need to be done separately
  methods_list <- methods_list %>%
    discard(methods_list %in% c("squidpy", "cellchat"))
  
  
  # map over every method except permutation ones
  top_dilutions_OP <- map(methods_list, function(method) {
    
    # Get the top_ranks from the liana_results for each dilution stage
    # using get_top_n_ranks()
    lapply(liana_results_OP[[method]][-1], 
           get_top_n_ranks, 
           method = method, 
           top_n = number_ranks[[method]])
    
  })
  
  
  # Because permutation methods produces so many interactions all tied for 0, 
  # we need to cut with ties
  top_dilutions_OP[["cellchat"]] <- 
    # Get the top_ranks from the liana_results for each dilution stage
    # using get_top_n_ranks() while cutting with ties
    lapply(liana_results_OP$cellchat[-1], 
           get_top_n_ranks, 
           method = "cellchat", 
           top_n = number_ranks$cellchat,
           with_ties = TRUE)  
  
  top_dilutions_OP[["squidpy"]] <- 
    # Get the top_ranks from the liana_results for each dilution stage
    # using get_top_n_ranks() while cutting with ties
    lapply(liana_results_OP$squidpy[-1], 
           get_top_n_ranks, 
           method = "squidpy", 
           top_n = number_ranks$squidpy,
           with_ties = TRUE)  
  

  
  
  # Merge with undiluted results, could use mapply but its less consistent
  for (method in methods_vector) {
    for (dilution in names(dilution_props)) {
      
      top_ranks_OP[[method]][[dilution]] <- 
        top_dilutions_OP[[method]][[dilution]]
      
    }
  }
  
  # Remove superfluous values
  rm(top_dilutions_OP, method, dilution, methods_list)
  
  
  # Formatting of top ranks
  
  # format top_ranks to have an ID that marks each specific interaction (LR and 
  # the source and target cell)
  for (method in methods_vector) {
    
    top_ranks_OP[[method]] <- 
      lapply(top_ranks_OP[[method]], unite, col = "LR_ID", 
             c(source, target, ligand, receptor), remove = FALSE)
    
  
  }
  
  
  # add a column to see if an interaction is fake
  for (method in methods_vector) {
    for (dilution in c("OmniPath_0", names(dilution_props))) {
      if( !(is_null(top_ranks_OP[[method]][[dilution]]))) {
        
        top_ranks_OP[[method]][[dilution]] <- 
          top_ranks_OP[[method]][[dilution]] %>%
          mutate(isRandom = 
                   !(LR_Pair %in% resources_OP$OmniPath_0$LR_Pair))
        
        
      } else {
        
        warning("One of the top_rank tibbles is missing! Moving on.")
        
      }
    }
  }
  
  # remove superfluous values
  rm(method,dilution)
  
    
  } # end of subpoint
  
  #3.3 Analysis of top_ranks
  {
  # Legend to what factors we look to analyse. Overlap is most important, the
  # rest interesting mostly in edge cases:
  #
  # Overlap               = What proportion of top ranked interactions 
  #                         (L + R + Source + Target) are identical between the 
  #                         results at dil = 0% and dil = *%.
  #
  # Mismatch              = 1 - Overlap, i.e. what proportion of top ranked 
  #                         interactions (L + R + Source + Target) are different 
  #                         between the results at dil = 0% and dil = *%.
  #
  # Randoms               = What proportion of top_ranked interactions at 
  #                         dil = *% are random, dilution produced interactions.
  #
  # Mismatch_from_Randoms = What proportion of mismatch is due to random
  #                         dilution based interactions that happen to be top 
  #                         ranked.
  # 
  # All_mismatch_from_Randoms  =  At a glance, is all the mismatch from Randoms?
  
  
  # lapply rank_overlap over the top rank tibbles, comparing the dilutions to 
  # the OP_0 at each stage.
  overlaps <- list()
  
  # Use the traditional case specific overlap normed by the larger value in the
  # traditional unmodified baseline
  if (modify_baseline == FALSE) {
    
    for (method in methods_vector) {
      
      if (method %in% c("cellchat", "squidpy")) {
        
        overlaps[[method]] <- 
          lapply(top_ranks_OP[[method]], 
                 permute_rank_overlap, 
                 main_ranks = top_ranks_OP[[method]]$OmniPath_0)
        
      } else {
        
        overlaps[[method]] <- 
          lapply(top_ranks_OP[[method]], 
                 rank_overlap, 
                 main_ranks = top_ranks_OP[[method]]$OmniPath_0)
        
      }
      
    }
  
  # Use the newer flexible overlap that always norms by the larger set for the
  # modified baseline. (Comparable to the other method, just simpler).
  } else if (modify_baseline == TRUE) {
    
    overlaps <- 
      map(methods_vector,
          function(method) {
            
            map(top_ranks_OP[[method]],
                rank_overlap_mod,
                main_ranks = top_ranks_OP[[method]]$OmniPath_0)
            
          })
    
    names(overlaps) <- methods_vector
    
  }
    
    

  
  # add NAs to the end of the overlaps where dilution wasn't possible
  # this way all the overlaps have the same length for tibble construction
  overlaps <- 
    lapply(overlaps, 
           function(x) { c(x, rep(NA, length(dilution_props)+1-length(x)))})
  
  
  
  
  # reformatting overlap as a tibble
  top_ranks_overlap <- as_tibble(overlaps)        %>%
    unnest(cols = all_of(methods_vector))         %>%
    mutate(dilution_prop = c(0, dilution_props))  %>%
    unnest(cols = c(dilution_prop))               %>%
    relocate("dilution_prop")
  
  # removing superfluous values
  rm(overlaps)
  
  
  
  # Top ranked interactions where isRandom = TRUE are products of dilutions.
  # If the diminished top_rank_overlap is exactly equal to the proportion of 
  # diluted interactions in the top_ranks, this indcates that dilution only 
  # messes with top ranks by creating candidates for false detection.
  
  # It could also be possible though that the proportion of dilutions in the 
  # top ranks doesn't fullly explain the diminishing overlap. In this case
  # dilutions may also alter the context such that real interactions that were
  # previously not top_ranked have become top_ranked.
  
  # Inaccuracy purely from random interactions being picked up on as top ranked
  # vs Inaccuracy from pushing previously not top ranked interactions into the
  # top ranks. This is an especially interesting comparison if top_ranked 
  # interactions can e diluted in the resource, as here the removal of previous 
  # top_ranks is felt greater.
  
  # We apply the prop_isRandom function, over every top_rank_df
  # Using lapply and sapply gives a convenient output layout that makes the 
  # formatting easier. 
  top_ranks_randoms <- lapply(top_ranks_OP, sapply, prop_isRandom) 
  
  # Because certain dilutions at higher dilution props might not have been 
  # achievable in respects to not changing top_ranked interactions. Because of
  # this, the sapply output may be short a few variables, which we correct by 
  # adding NAs until every vector that will become a column is has the same 
  # length of dilution_props. These NAs represent that the isRandom column
  # couldn't be analysed here, as no output was created.
  top_ranks_randoms <- 
    lapply(top_ranks_randoms, 
           function(x) { c(x, rep(NA, length(dilution_props)+1-length(x)))})
  
  # We format top_ranks_randoms the way we formatted top_ranks_overlap
  top_ranks_randoms <- top_ranks_randoms         %>%
    data.frame()                                 %>%
    as_tibble()                                  %>%
    mutate(dilution_prop = c(0, dilution_props)) %>%
    unnest(cols = c(dilution_prop))              %>%
    relocate("dilution_prop")                    %>%
    data.frame() #because we plan to do arithmetic operations with this tibble
  
  # The proportion of mismatch between top_rank_dfs is 1- the overlap
  # In order to perform this calculation top_ranks_overlap can't be a tibble
  top_ranks_mismatch                  <- 1 - data.frame(top_ranks_overlap)
  # We correct the dilutions column
  top_ranks_mismatch$dilution_prop    <- top_ranks_overlap$dilution_prop
  
  
  # What proportion of the mismatch is from diluted interactions picked up om
  # as top ranked? NaN = There was no mismatch here.
  mismatch_from_randoms               <- top_ranks_randoms / top_ranks_mismatch
  # Correct the dilutions column
  mismatch_from_randoms$dilution_prop <- top_ranks_randoms$dilution_prop
  
  
  # We store this variable in the environment so the user can find it more easily.
  All_mismatch_from_Randoms <- all.equal(top_ranks_randoms, 
                                         top_ranks_mismatch)
  
  
  # Summarizing all this information in one list makes things clear. 
  # Reconvert everything to tibbles as arithmetic operations should be over
  top_ranks_analysis <- 
    list("Overlap"                   = tibble(top_ranks_overlap),
         "Mismatch"                  = tibble(top_ranks_mismatch),
         "Randoms"                   = tibble(top_ranks_randoms),
         "Mismatch_from_Randoms"     = tibble(mismatch_from_randoms),
         "All_mismatch_from_Randoms" = All_mismatch_from_Randoms)
  
  
  # Get rid of superfluous values
  rm(top_ranks_overlap, 
     top_ranks_mismatch, 
     top_ranks_randoms, 
     mismatch_from_randoms, 
     All_mismatch_from_Randoms)
  
  } # end of subpoint
  
  
}




#------------------------------------------------------------------------------#
# 4. Returning results ------------------------------------------------------
{
  print_Title(
    str_glue("5. Returning results", "                   --  Iteration ", 
             master_seed))
  
  
  # 4.1 Tidying R environment and saving to Outputs under custom name
  {
      
    # stop the stopwatch
    runtime[[str_glue("Iteration Epilogue - Seed ", master_seed)]] <- Sys.time()  
    
    
    # let the user know where to find the log
    if(liana_warnings == "divert") {
      
      cat(str_wrap(str_glue("LIANA warnings saved at ~/", 
                            warning_logfile, "."), width = 60), " \n\n")
      
      # Keep the environment tidy
      rm(warning_logfile)
      
    }
  
    
    # Removing clutter
    rm(dilution_props, number_ranks, cellchat_nperms, feature_type, 
       methods_vector, preserve_topology)
    
  
    
  } # end of subpoint

  # 5.3 Bundling Outputs and returning Results
  {
    # Create one bundled object for the script to return
    results  <- list("liana_results_OP"   = liana_results_OP,
                     "resources_OP"       = resources_OP,
                     "top_ranks_OP"       = top_ranks_OP,
                     "top_ranks_analysis" = top_ranks_analysis,
                     
                     "runtime"            = runtime,
                     "testdata"           = testdata)
    
    # Filter it by the outputs the user requested
    results <- results[bundled_outputs]
   
    
  }
  
  
}

# Return results
return(results)

} # end of function


  
